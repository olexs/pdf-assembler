import * as child from 'child_process';
import util from 'util';
import * as fs from 'fs';
import * as path from 'path';

const exec = util.promisify(child.exec);

/**
 * Get the number of pages in a PDF using ImageMagick identify
 */
async function getPDFPageCount(pdfPath: string): Promise<number> {
    const { stdout } = await exec(`magick identify "${pdfPath}"`);
    const lines = stdout.trim().split('\n');
    return lines.length;
}

/**
 * Compare two PDF files using ImageMagick's compare command.
 * Handles multi-page PDFs by comparing each page individually.
 *
 * @param actualPath Path to the actual PDF generated by the test
 * @param expectedPath Path to the expected PDF baseline
 * @param diffPath Optional path to save visual diff output
 * @param threshold Maximum number of different pixels to tolerate (default: 0 for exact match)
 * @returns true if PDFs match within threshold, false otherwise
 */
export async function comparePDFs(
    actualPath: string,
    expectedPath: string,
    diffPath?: string,
    threshold: number = 0
): Promise<{ match: boolean; difference: number }> {
    // Check if expected file exists
    if (!fs.existsSync(expectedPath)) {
        console.log(`Expected PDF not found at ${expectedPath}. This may be the first run.`);
        return { match: false, difference: -1 };
    }

    try {
        // Get page counts for both PDFs
        const expectedPageCount = await getPDFPageCount(expectedPath);
        const actualPageCount = await getPDFPageCount(actualPath);

        if (expectedPageCount !== actualPageCount) {
            console.log(`PDF page count mismatch: expected ${expectedPageCount} pages, got ${actualPageCount} pages`);
            return { match: false, difference: -1 };
        }

        // Compare each page individually
        let totalDifference = 0;
        const fuzz = '5%';

        for (let pageIndex = 0; pageIndex < expectedPageCount; pageIndex++) {
            const diffOutput = diffPath
                ? diffPath.replace('.png', `-page${pageIndex}.png`)
                : path.join(path.dirname(actualPath), `diff-page${pageIndex}.png`);

            const command = `magick compare -metric AE -fuzz ${fuzz} "${expectedPath}[${pageIndex}]" "${actualPath}[${pageIndex}]" "${diffOutput}"`;

            try {
                const { stderr } = await exec(command);
                const pageDifference = parseInt(stderr.trim().split(' ')[0]);
                totalDifference += pageDifference;

                // Clean up diff file if page matches
                if (pageDifference === 0 && fs.existsSync(diffOutput)) {
                    fs.unlinkSync(diffOutput);
                }
            } catch (error) {
                // compare exits with non-zero status when images differ
                if (error.stderr) {
                    const pageDifference = parseInt(error.stderr.trim().split(' ')[0]);
                    totalDifference += pageDifference;
                } else {
                    throw error;
                }
            }
        }

        const match = totalDifference <= threshold;

        if (!match) {
            console.log(`PDF comparison failed: ${totalDifference} pixels differ across ${expectedPageCount} pages (threshold: ${threshold})`);
            console.log(`Diff images saved to: ${path.dirname(diffPath || actualPath)}`);
        }

        return { match, difference: totalDifference };
    } catch (error) {
        console.error(`Error comparing PDFs: ${error.message}`);
        throw error;
    }
}

/**
 * Save expected PDF baseline for future comparisons.
 * Copies the actual PDF to the expected location.
 */
export function saveExpectedPDF(actualPath: string, expectedPath: string): void {
    const expectedDir = path.dirname(expectedPath);
    if (!fs.existsSync(expectedDir)) {
        fs.mkdirSync(expectedDir, { recursive: true });
    }
    fs.copyFileSync(actualPath, expectedPath);
    console.log(`Saved expected PDF baseline: ${expectedPath}`);
}

/**
 * Get the expected PDF path for a test based on test name.
 * Platform-agnostic since PDF output should be identical across platforms.
 */
export function getExpectedPDFPath(testName: string): string {
    // Convert test name to filename (similar to Playwright's snapshot naming)
    const sanitized = testName.replace(/[^a-z0-9]+/gi, '-').toLowerCase();
    return path.join(__dirname, 'main.spec.ts-snapshots', `${sanitized}.pdf`);
}

/**
 * Get the actual PDF output path for a test.
 */
export function getActualPDFPath(testName: string): string {
    const sanitized = testName.replace(/[^a-z0-9]+/gi, '-').toLowerCase();
    return path.join(__dirname, 'outputs', `${sanitized}.pdf`);
}
